<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CryptoSpin - Rueda de Sorteo</title>
  <style>
    body {
      background: #121212;
      color: white;
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 1rem;
    }
    #wheelCanvas {
      margin: 0 auto;
      display: block;
      background: #222;
      border-radius: 50%;
      box-shadow: 0 0 15px #0f0;
    }
    button {
      margin-top: 20px;
      background-color: #28a745;
      border: none;
      color: white;
      padding: 12px 24px;
      font-size: 18px;
      border-radius: 30px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    button:disabled {
      background-color: #444;
      cursor: not-allowed;
    }
    #result {
      margin-top: 20px;
      font-size: 24px;
      font-weight: bold;
      min-height: 30px;
    }
  </style>
</head>
<body>

  <h1>CryptoSpin - Rueda de Sorteo</h1>

  <canvas id="wheelCanvas" width="500" height="500"></canvas>
  <br />
  <button id="spinButton">Girar Rueda</button>

  <div id="result"></div>

  <script>
    const canvas = document.getElementById("wheelCanvas");
    const ctx = canvas.getContext("2d");
    const spinButton = document.getElementById("spinButton");
    const resultDiv = document.getElementById("result");

    const segments = 200;
    const segmentAngle = (2 * Math.PI) / segments;
    const radius = canvas.width / 2 - 20;

    let currentAngle = 0;
    let angularVelocity = 0;
    let spinning = false;

    // Generar colores para segmentos (alternar dos colores para mejor visual)
    function getColor(i) {
      return i % 2 === 0 ? "#0f0" : "#050";
    }

    function drawWheel() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate(currentAngle);

      // Dibujar segmentos
      for (let i = 0; i < segments; i++) {
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.fillStyle = getColor(i);
        ctx.arc(0, 0, radius, i * segmentAngle, (i + 1) * segmentAngle);
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 0.3;
        ctx.stroke();

        // Números
        ctx.save();
        ctx.fillStyle = "white";
        ctx.translate(
          Math.cos(i * segmentAngle + segmentAngle / 2) * (radius - 25),
          Math.sin(i * segmentAngle + segmentAngle / 2) * (radius - 25)
        );
        ctx.rotate(i * segmentAngle + segmentAngle / 2 + Math.PI / 2);
        ctx.font = "10px Arial";
        ctx.textAlign = "center";
        ctx.fillText(i + 1, 0, 0);
        ctx.restore();
      }

      ctx.restore();

      // Indicador de flecha (fijo arriba)
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2 - 15, 10);
      ctx.lineTo(canvas.width / 2 + 15, 10);
      ctx.lineTo(canvas.width / 2, 40);
      ctx.closePath();
      ctx.fill();
    }

    function spin() {
      if (spinning) return;
      spinning = true;
      spinButton.disabled = true;
      resultDiv.textContent = "";

      const duration = 20000; // 20 segundos total
      const suspenseDuration = 5000; // últimos 5 segundos lentos
      const start = performance.now();

      const maxAngularVelocity = 0.6; // velocidad inicial
      const minAngularVelocity = 0.01; // velocidad mínima para "lento" final

      function animate(time) {
        const elapsed = time - start;
        if (elapsed >= duration) {
          spinning = false;
          angularVelocity = 0;

          // Calcular ganador
          const normalizedAngle = currentAngle % (2 * Math.PI);
          let winningIndex = Math.floor((segments - normalizedAngle / segmentAngle)) % segments;
          if (winningIndex < 0) winningIndex += segments;

          resultDiv.textContent = `¡Ganador: Segmento #${winningIndex + 1}!`;
          spinButton.disabled = false;
          return;
        }

        if (elapsed < duration - suspenseDuration) {
          // Desaceleración rápida (lineal) en los primeros 15 segundos
          angularVelocity = maxAngularVelocity * (1 - elapsed / (duration - suspenseDuration));
        } else {
          // Últimos 5 segundos: desaceleración muy suave (exponencial)
          const suspenseElapsed = elapsed - (duration - suspenseDuration);
          // Factor entre 0 y 1 para los últimos 5 segundos
          const t = suspenseElapsed / suspenseDuration;

          // Easing cuadrático invertido para ralentizar la velocidad
          angularVelocity = minAngularVelocity + (maxAngularVelocity - minAngularVelocity) * (1 - t) * (1 - t);
        }

        currentAngle += angularVelocity;
        drawWheel();

        requestAnimationFrame(animate);
      }

      requestAnimationFrame(animate);
    }

    drawWheel();

    spinButton.addEventListener("click", spin);
  </script>
</body>
</html>
